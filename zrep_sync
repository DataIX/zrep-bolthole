##### zrep_sync

# contains meat of the "sync" level operations.
# basic snap routines, and init rountines, are in zrep_snap


####################
# synctosnap: called by zrep_sync, if a specific snapshot is specified.
#
# This makes REMOTE side, match up with given local zrep_created snapshot.
# ...  but it also makes our local-side snapshot naming coordinate with that.
# 
# Note that it uses zrep_lock_fs
#
# WARNING: if we force other side to roll to snap.... 
#  we should NOT BE SYNCING ANY more.
# At the moment, it is up to the user to ensure that nothing is going on 
# locally, and future zrep syncs wont just effectively roll forward again
#  on the remote side.
# zrep sync jobs  should probably be halted, until it is decided that
# you want to sync again.
#
# In the future, I should support some kind of "pause" option, for 
#   zrep sync all    to ignore a rolled back filesystem
#
#
synctosnap(){
	typeset srcsnap=$1 destfs=$2 desthost=$3
	typeset newsentlist

	typeset srcfs snapname destsnap
	if [[ "$desthost" == "" ]] ; then
		print ERROR: synctosnap did not receive all required args
		zrep_errquit "args=$@"
	fi
	srcfs=${srcsnap%@*}
	snapname=${srcsnap#*@}
	destsnap=${snapname}

	# Have to enforce OUR syntax. otherwise, any future attempt to
	# continue sync will fail.
	#  ( getlastsnap() wont find it! )
	#
	case $snapname in
		zrep_[0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f]*)
		: ;;
		*)
			zrep_errquit $srcsnap is not zrep snapshot. Cannot roll with it.
		;;
	esac
		
		

	print Validating remote snap
	zrep_ssh $desthost zfs list -t snapshot $destfs@$destsnap >/dev/null
	if [[ $? -ne 0 ]] ; then
		zrep_errquit  $destfs@$destsnap does not exist. Cannot roll to snap
	fi
	

	print "WARNING: We will be rolling back  $destfs, on $desthost"
	print -n "   to  $snapname, made at: "
	zfs get -H -o value creation $srcsnap
	print ""
	print "All newer snapshots on remote side will be destroyed"
	print "You should have paused ongoing sync jobs for $destfs before continuing"
	print "Continuing in 20 seconds...."
	sleep 10
	print "Continuing in 10 seconds...."
	sleep 10

	zrep_lock_fs $srcfs || zrep_errquit "Cannot lock $srcfs"
	zrep_ssh $desthost zfs rollback -Rr $destfs@$destsnap || zrep_errquit roll failed

	print $desthost:$destfs rolled back successfully to $destsnap
	print Now cleaning up local snapshots

	# need to undo whatever zrep_sync does 
	newsentlist=`getallsnaps $srcfs|sed "1,/@$snapname/d"`
	for snap in $newsentlist ; do
		zfs inherit zrep:sent $snap
	done

	zrep_unlock_fs $srcfs
	
}

#  _sync  fs desthost destfs
# internal routine called by zrep_sync and zrep_failover
# You must hold filesystem lock before calling this
# Other than checking lock, WE DO NOT DO ANY CHECKS HERE.
#
# Wil create a new snap on srcfs, and sync it over to given destination
# Sets our 'synced' marker on it as well.
#
_sync(){
	typeset srcfs=$1 desthost=$2 destfs=$3
	typeset sentsnap newsnap snapname
	typeset timeinsec=`zrep_gettimeinseconds`
	typeset senttimeprop="zrep:sent=$timeinsec"


	#srchost=`zfs get -H -o value zrep:src-host $srcfs`
	#if [[ "$srchost" != "$Z_LOCAL_HOST" ]] ; then
	#	zrep_errquit _sync: We are not master for $srcfs
	#fi


	sentsnap=`getlastsnapsent $srcfs`
	if [[ "$sentsnap" == "" ]] ; then
		print zrep_sync could not find sent snap for $srcfs. 
		zrep_errquit You must initialize $srcfs for zrep
	fi

	newsnap=`makesnap $srcfs`
	if [[ "$newsnap" == "" ]] ; then
		zrep_errquit zrep_sync could not create new snapshot for $srcfs
	fi
	snapname=${newsnap#*@}


	print sending $newsnap to $desthost:$destfs

	# Note: doing "-o $senttimeprop" sets prop on FILESYSTEM, not snap.
	# So we dont do that usually

	zfs send -I $sentsnap $newsnap | 
	   zrep_ssh $desthost zfs recv $destfs
	if [[ $? -ne 0 ]] ; then
		zfs rename ${newsnap} ${newsnap}_unsent
		zrep_errquit Problem doing sync for $newsnap
	fi

	#Even if we are "old mode", other side may not be.
	# So try newer way first.
	zrep_ssh $desthost zfs set $senttimeprop $destfs@$snapname
	if [[ $? -ne 0 ]] ; then
		print WARNING: setting zrep:sent failed on $desthost:$destfs@$snapname
		print Using fallback. Go patch your system
		zrep_ssh $desthost zfs set zrep:lastsent=${newsnap} $destfs
		zrep_ssh $desthost zfs set zrep:lastsenttime=${timeinsec} $destfs
	fi

	if (( Z_HAS_SNAPPROPS )) ; then
		zfs set $senttimeprop  ${newsnap}
	else
		#note that this is only for old-ZFS compatibility.
		# We dont really want to use this style if possible!
		zfs set zrep:lastsent=${newsnap} $srcfs
		zfs set zrep:lastsenttime=${timeinsec} $srcfs
	fi
}



#zrep_sync
# make a new snapshot and copy it over.
# Usage: zrep_sync [-q quiettime] (all|fs1 .. fsX)
# See workflow.txt 
# Will call synctosnap if a snapshot is given instead of fsname
# Normally, will bail out if another instance of zrep holds lock.
#   -q option says to check last update time of locked filesystems.
#   If sync more recent than given quiettime, then quietly ignore
#   
zrep_sync(){
	typeset srcfs destfs desthost sentsnap newsnap
	typeset quiettime=0

	if [[ "$1" == "-q" ]] ; then
		quiettime="$2"
		shift
		shift
		if (( quiettime < 30 )) ; then
			zrep_errquit "-q must use value greater than 30"
		fi
	fi

	if [[ "$1" == "all" ]] ; then
		set -- `zrep_list_master`
		if [[ "$1" == "" ]] ; then
			# Stay quiet, so we dont spew if in cron
			#print No zrep mastered filesystems found
			exit
		fi
	fi

	if [[ "$1" == "" ]] ; then
		print Error: no filesystems specified for sync >/dev/fd/2
		return 1
	fi

	while [[ "$1" != "" ]] ; do
	srcfs="$1" 

	[[ "$srcfs" == "" ]] && zrep_errquit No fileystem specified for sync

	desthost=`zfs get -H -o value zrep:dest-host $srcfs`
	destfs=`zfs get -H -o value zrep:dest-fs $srcfs`
	if [[ $? -ne 0 ]] || [[ "$remhost" == "-" ]] || [[ "$remfs" == "-" ]];
	then
		zrep_errquit Problem getting zrep properties for fs $srcfs
	fi
	
	case $srcfs in
		*@*)
			synctosnap $srcfs $destfs $desthost
			return
			;;
	esac

	zrep_lock_fs $srcfs
	if [[ $? -ne 0 ]] ; then

		if ((quiettime==0)); then
			zrep_errquit Cannot lock $srcfs. Cannot continue
		fi
		typeset currtime=`zrep_gettimeinseconds`  snaptime elapsed

		snaptime=`getlastsynctime $srcfs`
		if (( snaptime == 0 )) ; then
			zrep_errquit quiet mode set, but no last snap for $srcfs
		fi

		elapsed=$((currtime - snaptime))
		if ((elapsed > quiettime)) ; then
			print DEBUG: $elapsed seconds have elapsed since last sync of $srcfs
			zrep_errquit quiet time limit of $quiettime seconds exceeded for busy fs $srcfs
		else
			print Quiet mode: skipping busy fs $srcfs at `date`
			return 
		fi
	fi

	_sync $srcfs $desthost $destfs



	# Make this message match what zrep_expire uses..
	print Expiring zrep snaps on $srcfs
	_expire $srcfs

	zrep_unlock_fs $srcfs

	shift

	done

}



# _expire: 
#   get rid of "old" snapshots for a specifically named filesystem
#
# Note0: you must hold local(master) fs lock first
#
# Note1: expire BOTH SIDES, if we are master
# Keep in mind that sometimes master and dest are on same system
# 
# Note2: Be sure to NEVER delete most recent sent snapshot!!

# INTERNAL routine. For external-facing routine, see zrep_expire
_expire(){
	typeset savecount currcount lastsent remotehost remotefs sanity
	typeset tmpfile=/var/run/zrep_expire.$$
	typeset local=0 master

	if [[ "$1" == "-L" ]] ; then
		local=1;
		shift
	fi

	master=`zfs get -H -o value -s local zrep:master $1`

	zrep_has_fs_lock $1 || zrep_errquit zrep_expire Internal Err caller did not hold fs lock

	savecount=`zfs get -H -o value zrep:savecount $1`
	# do not use (()) in case value unset
	if [[ $savecount < 1 ]] ; then
		zrep_errquit zrep:savecount on $1 set to improper value $savecount
	fi

	if [[ "$master" == "yes" ]] ; then
		lastsent=`getlastsnapsent $1`
		if [[ "$lastsent" == "" ]] ; then
			zrep_errquit corrupted zrep data: no last sent detected. Stopping expire
		fi

		getallsnaps $1 |egrep -v $lastsent >$tmpfile
		savecount=$((savecount-1))
	else
		getallsnaps $1 >$tmpfile
	fi
	currcount=`wc -l < $tmpfile`

	if ((currcount > savecount )) ; then
		currcount=$((currcount - savecount))

		head -$currcount $tmpfile >$tmpfile.2
		mv $tmpfile.2 $tmpfile
		for snap in `cat $tmpfile` ; do
			print DEBUG: expiring $snap
			zfs destroy $snap
		done
	fi
	rm $tmpfile
	

	if [[ "$master" != "yes" ]] || ((local ==1)) ; then
		#This fs is dest fs. We are done.
		return
		#otherwise, go expire on remote side as well
	fi

	remotehost=`zfs get -H -o value zrep:dest-host $1`
	remotefs=`zfs get -H -o value zrep:dest-fs $1`
	print Also running expire on $remotehost:$remotefs now...
	sanity=`zrep_ssh $remotehost zfs get -H -o value -s local zrep:master $remotefs`

	# Normally, dont quit on error. But this is super-bad.
	if [[ "$sanity" == "yes" ]] ; then
		zrep_errquit "Remote side also marked as master ** $remotehost:$remotefs"
	fi

	zrep_ssh $remotehost $ZREP_PATH expire $remotefs ||print REMOTE expire failed
}


# top-level user-facing routine.
# expire old snaps for some or all zrep filesystems.
# Different ways of calling:
#   zrep expire all	Run expire on all zrep fs
#   zrep expire		Run expire on zrep fs we are master for, plus remote
#   zrep expire	-L	Run expire on zrep fs we are master for. SKIP remote
#   zrep expire	 fs ..	Run expire only on fs, plus remote if it is a master
#   zrep expire	-L fs 	Run expire only on fs. Skip remote
#
# If no arg given, expire only filesystems we are master for
# If "all" given, expire literally all.
#
zrep_expire()
{
	typeset local
	if [[ "$1" == "-L" ]] ; then
		local="-L"
		shift
	fi

	if [[ "$1" == "all" ]] ; then
		set -- `zrep_list`
	elif [[ "$1" == "" ]] ; then
		set -- `zrep_list_master`
	fi

	# Note: we should continue if we hit problems with an individual
	# filesystem. Otherwise we risk letting server selfdestruct fill
	# over one troublesome filesystem
	#
	while [[ "$1" != "" ]] ; do
		zrep_lock_fs $1
		print Expiring zrep snaps on $1
		 _expire $local $1 || print WARNING: expire failed for $1
		zrep_unlock_fs $1
		shift
	done
	
}
